//控制组件模式和集成模式
if (rootProject.ext.isApplication && rootProject.ext.isTodoApplication) {
    apply plugin: 'com.android.application'
    // 应用 Android AspectJ 插件
    apply plugin: 'android-aspectjx'
} else {
    apply plugin: 'com.android.library'
}
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
// Realm 数据库 插件
apply plugin: 'realm-android'

android {
    //签名配置
    signingConfigs {
        debug {
            final Properties properties = getKeyStoreProperties()

            if (properties != null && !properties.isEmpty()) {
                storeFile file(properties.getProperty("DEBUG_KEY_STORE_FILE"))
                storePassword properties.getProperty("DEBUG_KEY_STORE_PASSWORD")
                keyAlias properties.getProperty("DEBUG_KEY_ALIAS")
                keyPassword properties.getProperty("DEBUG_KEY_PASSWORD")
            } else {
                // gradle run 控制台 打印 ERROR级别 日志
                project.logger.log(LogLevel.ERROR, "todo模块 Debug签名配置文件未发现!")
            }
        }
        release {
            final Properties properties = getKeyStoreProperties()

            if (properties != null && !properties.isEmpty()) {
                storeFile file(properties["RELEASE_KEY_STORE_FILE"])
                storePassword properties["RELEASE_KEY_STORE_PASSWORD"]
                keyAlias properties["RELEASE_KEY_ALIAS"]
                keyPassword properties["RELEASE_KEY_PASSWORD"]
            } else {
                // gradle run 控制台 打印 ERROR级别 日志
                project.logger.log(LogLevel.ERROR, "todo模块 Release签名配置文件未发现!")
            }
        }
    }

    compileSdkVersion rootProject.ext.android.compileSdkVersion
    buildToolsVersion rootProject.ext.android.buildToolsVersion

    defaultConfig {
        if (rootProject.ext.isApplication && rootProject.ext.isTodoApplication) {
            //Application模式下 设置applicationId
            applicationId rootProject.ext.android.applicationId
        }
        minSdkVersion rootProject.ext.android.minSdkVersion
        targetSdkVersion rootProject.ext.android.targetSdkVersion
        versionCode rootProject.ext.android.versionCode
        versionName rootProject.ext.android.versionName

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        //配置阿里 ARouter 路由
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }

        // 腾讯X5 必须显式指定 armeabi so库
        // 大厂APP一般只有一个 armeabi so库文件
        // Realm 不支持 armeabi, 故改为添加 armeabi架构 armeabi-v7a
        // 注意: 不能使用 arm64-v8a, 否则腾讯x5会初始化失败 (腾讯x5为了兼容, 只支持armeabi架构)
        ndk {
            abiFilters "armeabi-v7a"
        }
        // 开启MultiDex
        multiDexEnabled = true
    }

    buildTypes {
        //正式模式
        release {
            //正式模式
            buildConfigField "boolean", "IS_DEBUG", "false"
            //正式版构建时间
            buildConfigField "String", "buildTime", "\"" + getRealTime() + "\""

            //是否开启混淆
            minifyEnabled true
            //Zipalign优化
            zipAlignEnabled true
            // 移除无用的resource文件 (如果为true, 那么 getIdentifier(根据资源ID字符串获取资源) 可能获取不到(资源被删除了))
            shrinkResources false
            // 判断是 应用模式 还是 库模式
            if (rootProject.ext.isApplication && rootProject.ext.isTodoApplication) {
                // 使用应用模式混淆文件
                proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                // 使用正式版签名配置签名
                signingConfig signingConfigs.release
            } else {
                // 使用库模式混淆文件
                consumerProguardFiles 'consumer-rules.pro'
            }
        }
        //调试模式
        debug {
            //调试模式
            buildConfigField "boolean", "IS_DEBUG", "true"
            //调试版构建时间
            buildConfigField "String", "buildTime", "\"" + getRealTime() + "\""

            //是否开启混淆，开启之后不能debug
            minifyEnabled false
            //Zipalign优化
            zipAlignEnabled true
            // 移除无用的resource文件 (如果为true, 那么 getIdentifier(根据资源ID字符串获取资源) 可能获取不到(资源被删除了))
            shrinkResources false
            //应用模式下, 使用调试版签名配置签名
            if (rootProject.ext.isApplication && rootProject.ext.isTodoApplication) {
                // 使用应用模式混淆文件
                proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                signingConfig signingConfigs.debug
            } else {
                // 使用库模式混淆文件
                consumerProguardFiles 'consumer-rules.pro'
            }
        }
    }
    //开启DataBinding (注意每个用到DataBinding的Module都需要打开) (用于 gradle tool 4.0 以上)
    buildFeatures{
        dataBinding = true
    }
    //Android Studio 4.0 以下 使用
    //开启DataBinding (注意每个用到DataBinding的Module都需要打开)
//    dataBinding {
//        enabled true
//    }
    //开启Java8
    compileOptions {
        sourceCompatibility = 1.8
        targetCompatibility = 1.8
    }
    // 解决问题 (Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6. Please specify proper '-jvm-target' option)
    kotlinOptions {
        jvmTarget = "1.8"
    }
    //支持 ViewHolder 中使用 Kotlin 的 findViewById 简写
    androidExtensions {
        experimental = true
    }
    //Realm 开启 Kotlin 支持
    realm {
        kotlinExtensionsEnabled = true
    }
    if (isApplication && isTodoApplication) {
        // 解决 AspectJ 一系列问题
        aspectjx{
            // 目前已知问题: kotlin-gradle-plugin 和 kotlin-stdlib-jdk7  1.4.0会报 zip is empty, 而1.3.72则没问题
            // 关闭AspectJX功能
            enabled false
            exclude 'androidx', "com.google", "io.realm", "leakcanary"
        }
    }
    //避免项目中存在相同的jar包，导致运行失败
    dexOptions {
        preDexLibraries = false
    }
    //出现错误的原因是：AndroidStudio严格审查png图片，就是png没有达到AndroidStudio的要求
    //注：最重要的就是.9图要严格要求做好。禁止Gradle检查PNG的合法性
    aaptOptions.cruncherEnabled = false
    aaptOptions.useNewCruncher = false

    //lint配置信息，这里主要是设置自定义lint检测后报告路径，LintOptions类型
    //命令行：gradlew lint      注意，studio自带lint检查，setting——> Inspection
    lintOptions {
//        println("开始执行lint检测代码逻辑")
//        // 设置为 true，则当 Lint 发现错误时停止 Gradle 构建
//        //移除lint检测的error
//        abortOnError false
//        // 设置为 true，则当有错误时会显示文件的全路径或绝对路径 (默认情况下为true)
//        absolutePaths true
//        // 仅检查指定的问题（根据 id 指定）
//        check 'NewApi', 'InlinedApi'
//        // 设置为 true 则检查所有的问题，包括默认不检查问题
//        checkAllWarnings true
//        // 设置为 true 后，release 构建都会以 Fatal 的设置来运行 Lint。
        // 如果构建时发现了致命（Fatal）的问题，会中止构建（具体由 abortOnError 控制）
//        checkReleaseBuilds false
//        // 不检查指定的问题（根据问题 id 指定）
//        disable 'TypographyFractions','TypographyQuotes'
//        // 检查指定的问题（根据 id 指定）
//        enable 'RtlHardcoded','RtlCompat', 'RtlEnabled'
//        // 在报告中是否返回对应的 Lint 说明
//        explainIssues true
//        // 写入报告的路径，默认为构建目录下的 lint-results.html
//        //htmlOutput file("lint-report.html")
//        // 设置为 true 则会生成一个 HTML 格式的报告
//        htmlReport true
//        // 设置为 true 则只报告错误
//        ignoreWarnings true
//        // 重新指定 Lint 规则配置文件
//        //lintConfig file("default-lint.xml")
//        // 设置为 true 则错误报告中不包括源代码的行号
//        noLines true
//        // 设置为 true 时 Lint 将不报告分析的进度
//        quiet true
//        // 设置为 true 则显示一个问题所在的所有地方，而不会截短列表
//        showAll true
//        // 配置写入输出结果的位置，格式可以是文件或 stdout
//        textOutput 'stdout'
//        // 设置为 true，则生成纯文本报告（默认为 false）
//        textReport false
//        // 设置为 true，则会把所有警告视为错误处理
//        warningsAsErrors true
//        // 写入检查报告的文件（不指定默认为 lint-results.xml）
//        //xmlOutput file("lint-report.xml")
//        // 设置为 true 则会生成一个 XML 报告
//        xmlReport false
//        // 将指定问题（根据 id 指定）的严重级别（severity）设置为 Fatal
//        fatal 'NewApi', 'InlineApi'
//        // 将指定问题（根据 id 指定）的严重级别（severity）设置为 HttpException
//        error 'Wakelock', 'TextViewEdits'
//        // 将指定问题（根据 id 指定）的严重级别（severity）设置为 Warning
//        warning 'ResourceAsColor'
//        // 将指定问题（根据 id 指定）的严重级别（severity）设置为 ignore
//        ignore 'TypographyQuotes'
    }

    sourceSets {
        main {
            if (rootProject.ext.isApplication && rootProject.ext.isTodoApplication) {
                manifest.srcFile 'src/main/manifest/application/AndroidManifest.xml'
            } else {
                manifest.srcFile 'src/main/manifest/library/AndroidManifest.xml'
            }
            jniLibs.srcDirs = ['libs']
            java {
                srcDirs('src/main/java', 'src/main/kotlin')
            }
            resources {
                srcDirs('src/main/res')
            }
        }
    }

    sourceSets.all { set ->
        println "${set.name} 的文件是 ${set.java.srcDirs}"
    }

}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar', '*.aar'])

    //依赖 base 模块
    implementation project(path: ':base')

    //Room 数据库存储 注解执行器
    kapt rootProject.ext.annotationProcessor["room"]
    //ARouter 路由框架 注解执行器
    kapt rootProject.ext.annotationProcessor["arouter"]
}

//获取实时时间
private static def getRealTime() {
    return System.currentTimeMillis().toString()
}

//读取项目中的keystore.properties签名文件，安全
private static Properties getKeyStoreProperties() {
    final File propertiesFile = new File("..\\keystore.properties")
    final Properties properties = new Properties()

    if (propertiesFile.exists()) {
        properties.load(new FileInputStream(propertiesFile))
    }
    return properties
}